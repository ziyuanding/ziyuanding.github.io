<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://ziyuanding.github.io/</link><description>Recent content on</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Fri, 10 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://ziyuanding.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>https://ziyuanding.github.io/about/</link><pubDate>Fri, 10 Oct 2025 00:00:00 +0000</pubDate><guid>https://ziyuanding.github.io/about/</guid><description>&lt;h1 id="about-me"&gt;About Me&lt;/h1&gt;
&lt;p&gt;这里写你的介绍，比如研究方向、个人经历、联系方式等。&lt;/p&gt;</description></item><item><title>在WSL里使用Zerotier但SSH无法连接SSH2_MSG_KEX_ECDH_REPLY</title><link>https://ziyuanding.github.io/posts/%E5%9C%A8wsl%E9%87%8C%E4%BD%BF%E7%94%A8zerotier%E4%BD%86ssh%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/</link><pubDate>Sat, 27 Sep 2025 00:00:00 +0000</pubDate><guid>https://ziyuanding.github.io/posts/%E5%9C%A8wsl%E9%87%8C%E4%BD%BF%E7%94%A8zerotier%E4%BD%86ssh%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5/</guid><description>&lt;h1 id="bug-调查文档wsl-内-zerotier-ssh-连接卡住问题"&gt;Bug 调查文档：WSL 内 ZeroTier SSH 连接卡住问题&lt;/h1&gt;
&lt;h2 id="问题描述"&gt;问题描述&lt;/h2&gt;
&lt;p&gt;在两台 Windows 机器 A 和 B 上，都安装了 WSL 和 ZeroTier(A在windows和wsl都安装了zerotier, B只在wsl里安装了zerotier) 的情况下，出现以下问题(均以ssh连接，地址使用zerotier的vpn ip)：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;A 的 Windows → B 的 WSL&lt;/strong&gt;：可以正常连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A 的 WSL → B 的 WSL&lt;/strong&gt;：SSH 连接卡住。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;A 的 WSL → 其他处于VPN的机器&lt;/strong&gt;：ZeroTier 可以正常连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体表现为在 SSH 调试日志中卡在：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="排查过程"&gt;排查过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析 SSH debug 日志&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端版本：OpenSSH_9.6p1&lt;/li&gt;
&lt;li&gt;服务端版本：OpenSSH_8.2p1&lt;/li&gt;
&lt;li&gt;握手开始正常，算法协商成功：
&lt;pre tabindex="0"&gt;&lt;code&gt;kex: algorithm: curve25519-sha256
kex: host key algorithm: ssh-ed25519
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;卡在等待 &lt;code&gt;SSH2_MSG_KEX_ECDH_REPLY&lt;/code&gt;，未收到服务端回应。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析 ZeroTier 网络情况&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A 的 WSL 可以通过 ZeroTier 连接其他机器，说明 WSL 内 ZeroTier 正常。&lt;/li&gt;
&lt;li&gt;B 的 WSL 可以被 A 的 Windows 访问，说明 B 的 WSL ZeroTier 正常。&lt;/li&gt;
&lt;li&gt;问题只发生在 &lt;strong&gt;A 的 WSL → B 的 WSL&lt;/strong&gt;，提示可能是网络层（路由/NAT/MTU）问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;推测原因&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>在WinSCP里使用rsync</title><link>https://ziyuanding.github.io/posts/%E5%9C%A8winscp%E9%87%8C%E4%BD%BF%E7%94%A8rsync/</link><pubDate>Sat, 21 Dec 2024 00:00:00 +0000</pubDate><guid>https://ziyuanding.github.io/posts/%E5%9C%A8winscp%E9%87%8C%E4%BD%BF%E7%94%A8rsync/</guid><description>&lt;p&gt;rsync是一个好用的文件传输工具。对我来说，它比scp好的一点是，它可以解析远程机器中软链接里的内容，并在下载到本地时抹平了软链接。&lt;/p&gt;
&lt;p&gt;我本地机器使用的是Windows操作系统，需要安装cwRsync，Linux系统则正常安装rsync就行（多半发行版已经自带了）:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;scoop install main/cwrsync
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你习惯于直接用命令行，那么便可以直接执行：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;rsync -avzL -e &amp;#34;ssh -i ~/.ssh/id_ed25519&amp;#34; &amp;lt;远程机器用户名&amp;gt;@&amp;lt;远程机器地址&amp;gt;:&amp;lt;远程文件路径&amp;gt; &amp;lt;本地路径&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里用到了ssh来登录远程机器，如果你用的是Windows系统，默认使用的是自带的openSSH，多半会报错：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;rsync: connection unexpectedly closed (0 bytes received so far) [receiver] 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;来自 &lt;a href="https://stackoverflow.com/questions/7261029/why-is-this-rsync-connection-unexpectedly-closed-on-windows"&gt;https://stackoverflow.com/questions/7261029/why-is-this-rsync-connection-unexpectedly-closed-on-windows&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很有可能是ssh的问题，我在Windows上最终使用的命令是这样的，用的cwRsync自带的ssh：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;rsync -avzL -e &amp;#34;~\scoop\apps\cwRsync\6.3.2\bin\ssh.exe -i ~/.ssh/id_ed25519&amp;#34; &amp;lt;远程机器用户名&amp;gt;@&amp;lt;远程机器地址&amp;gt;:&amp;lt;远程文件路径&amp;gt; &amp;lt;本地路径&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我还希望能在WinSCP里操作。WinSCP是一个文件传输的GUI。我希望我能点选一个文件夹，然后点击一个自定义按钮来执行我上面写的rsync命令。&lt;/p&gt;
&lt;p&gt;最终写出来的是这样的，我不知道为什么winscp必须要经过cmd才能用其他命令，直接用rsync不被识别。&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;cmd /c &amp;#34;D: &amp;amp;&amp;amp; cd / &amp;amp;&amp;amp; rsync -avzL -e &amp;#39;~\scoop\apps\cwRsync\6.3.2\bin\ssh.exe -i ~/.ssh/id_ed25519&amp;#39; &amp;lt;远程机器用户名&amp;gt;@&amp;lt;远程机器地址&amp;gt;:!/!&amp;amp; &amp;#39;&amp;lt;本地相对于D盘根目录的路径&amp;gt;&amp;#39; --log-file=&amp;#39;&amp;lt;本地相对于D盘根目录的路径&amp;gt;/rsync.log&amp;#39;&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解释一下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;D: 切换盘符&lt;/li&gt;
&lt;li&gt;cd / 切到D盘的根目录。直接切换盘符并不一定移动到根目录（而是上次所在的目录）。&lt;/li&gt;
&lt;li&gt;&amp;ndash;log-file=xxx rsync的传输日志，调试用。&lt;/li&gt;
&lt;li&gt;!/!&amp;amp; 选中的远程目录路径，这个是WinSCP的自己的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WinSCP自定义命令的时候，勾选“本地命令 Local command”和“使用远程文件 Use remote files”&lt;/p&gt;
&lt;p&gt;最终效果：
&lt;img src="2024-12-21-12-10-21.png" alt="最终效果"&gt;&lt;/p&gt;</description></item><item><title>如何关闭SparkMail的更新提示</title><link>https://ziyuanding.github.io/posts/%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%ADsparkmail%E7%9A%84%E6%9B%B4%E6%96%B0%E6%8F%90%E7%A4%BA/</link><pubDate>Sat, 07 Dec 2024 00:00:00 +0000</pubDate><guid>https://ziyuanding.github.io/posts/%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%ADsparkmail%E7%9A%84%E6%9B%B4%E6%96%B0%E6%8F%90%E7%A4%BA/</guid><description>&lt;p&gt;我常用 Spark Mail，它是一个支持多个邮箱的同步的客户端。但是它更新非常频繁，几乎每两天就会有一个更新，且会弹出一个窗口打断你现在的工作。客户端内并没有开关来控制这个通知的频率，也没有彻底关闭更新的选项。所以我想彻底关闭它。&lt;/p&gt;
&lt;p&gt;Spark Mail 是一个Electron应用，找到应用位置后使用asar进行解包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;npm install -g asar
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;asar extract app.asar app_unpacked
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;经过在app_unpacked内的一番寻找，发现Spark Mail使用 Sprkle 更新框架。在其配置文件中，有一个appcast URL: &lt;a href="https://downloads.sparkmailapp.com/Spark3/win/dist/appcast.xml"&gt;https://downloads.sparkmailapp.com/Spark3/win/dist/appcast.xml&lt;/a&gt; Spark Mail会在服务端更新这个xml, 而我们本地的客户端会不定时地检查这个xml的内容。到这里就简单了，屏蔽这个地址就可以了。&lt;/p&gt;
&lt;p&gt;在 C:\Windows\System32\drivers\etc\hosts 内添加 127.0.0.1 downloads.sparkmailapp.com 即可。&lt;/p&gt;</description></item><item><title>有没有必要手动安装CUDA</title><link>https://ziyuanding.github.io/posts/%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85cuda/</link><pubDate>Mon, 22 Apr 2024 00:00:00 +0000</pubDate><guid>https://ziyuanding.github.io/posts/%E6%9C%89%E6%B2%A1%E6%9C%89%E5%BF%85%E8%A6%81%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85cuda/</guid><description>&lt;p&gt;必须要有的东西是CUDA驱动和CUDA运行时。&lt;/p&gt;
&lt;p&gt;CUDA驱动，一般你就正常安装显卡驱动就有，常打游戏的话电脑上应该有一个nVidia experience，这个软件就是更新驱动的。下载最新的就行。新电脑或新装系统会需要更新这个驱动。安装这个驱动会给你&lt;code&gt;nvidia-smi&lt;/code&gt;这个命令。如果这个命令找不到，那就说明没装驱动。&lt;/p&gt;
&lt;p&gt;CUDA运行时，就是下面主要讨论的东西了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;手动安装CUDA和cuDNN（完整）&lt;/p&gt;
&lt;p&gt;比较传统的做法。去nVidia官网下载一个可执行安装文件，一路点下一步，等安装完后你就可以有nvcc这种东西了，一般你能找到的教程不是都让你用&lt;code&gt;nvcc -V&lt;/code&gt;来验证安装是否成功嘛。&lt;/p&gt;
&lt;p&gt;安装的东西是最全的，什么visual studio integration啊、nVidia Experience啦、Nsight啦，一不注意就都装上了。&lt;/p&gt;
&lt;p&gt;切换版本比较麻烦，需要自己写脚本改环境变量（&lt;code&gt;CUDA_PATH&lt;/code&gt;）
cuDNN的话，去nVidia官网下载，就是一堆文件，不用“安装”。复制粘贴到CUDA目录里就可以了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用PyTorch（不完整）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PyTorch&lt;/code&gt;是自带CUDA和cuDNN的。只要你有nVidia的显卡以及安装了合适的驱动，直接按照PyTorch官网的命令安装PyTorch，然后你就可以写代码运行程序了。虽然nvcc没有，但是丝毫不影响你跑程序。下面这段测试程序是可以通过的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;torch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cuda&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_available&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cuda&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__version__&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cuda&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;device_count&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cuda&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_device_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cuda&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;current_device&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;backends&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cudnn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;torch.backends&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cudnn&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cudnn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_available&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;torch&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tensor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cuda&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cudnn&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_acceptable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cuda&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般是和虚拟环境搭配使用，所以我觉得切换版本也方便。不过既然已经统一为torch实现了，个人认为其实也没什么切换CUDA版本的需求。。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟环境内安装CUDA和CUDNN（不完整）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;conda install &lt;span class="nv"&gt;cudatoolkit&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;11.8.0 &lt;span class="nv"&gt;cudnn&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;8.9.2.26 -c conda-forge
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 或者使用nvidia的源。因为有一些版本在conda-forge上没有，需要两个源都搜一下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;conda install cudatoolkit cudnn -c nvidia
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# cudatoolkit还是cuda-toolkit？ &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# cudatoolkit内容少，cuda-toolkit内容全，cuda内容最全&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# https://stackoverflow.com/questions/76875734/difference-between-nvidia-cuda-toolkit-and-nvidia-cudatoolkit-packages&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样安装好后，你的程序使用这个虚拟环境，也能正常运行。一些非pytorch框架实现的模型就可以这么安装依赖。&lt;/p&gt;
&lt;p&gt;同样的，没有nvcc。原理和pytorch差不多，因为只安装了CUDA的最小部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟环境内安装CUDA和CUDNN（完整）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# 这个cuda相当于是一本书的目录，会给你把一堆东西都装上，就像你直接从官网下载安装一样。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;conda install cuda -c conda-forge
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;烦，我现在搞不清nvidia-container的存在意义了。我觉得这个虚拟环境还能装完整版CUDA运行时的做法已经满足需求了。。。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nvidia-container-toolkit（完整）&lt;/p&gt;
&lt;p&gt;从这里可以知道（https://www.cnblogs.com/renoyuan/p/17809212.html）, nvidia-docker + nvidia-container-runtime 已经过时。直接来看nvidia-container-toolkit。&lt;/p&gt;
&lt;p&gt;我觉得只有在你需要完整CUDA，也就是pytoch自带的CUDA和使用conda安装的CUDA提供不了你需要的东西，比如nvcc时，可以尝试这种。基于容器，可以实现完整CUDA runtime的分离。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;先这么写着、、&lt;/p&gt;</description></item><item><title>sklearn的LogisticRegressionCV</title><link>https://ziyuanding.github.io/posts/sklearn%E7%9A%84logisticregressioncv/</link><pubDate>Mon, 08 Apr 2024 00:00:00 +0000</pubDate><guid>https://ziyuanding.github.io/posts/sklearn%E7%9A%84logisticregressioncv/</guid><description>&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sklearn.linear_model&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;LogisticRegressionCV&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;lr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LogisticRegressionCV&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;C_RANGE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;scoring&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;neg_log_loss&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;lr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X_train_full&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y_train_full&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;lr&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scores_&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;LogisticRegressionCV的求解器中基本都会用到warm-start，既下一次的拟合过程中，参数会被上一次的拟合过程影响。这是它速度快的原因。这也解释了为什么上面的代码和下面的代码跑出来的结果不一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;C_RANGE&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;lm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LogisticRegressionCV&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Cs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;scoring&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;neg_log_loss&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;lm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;X_train_full&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y_train_full&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;scores_&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ll&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然，使用第一个C值拟合时的结果是一样的，因为这时候warm-start并没有”上一轮“。&lt;/p&gt;
&lt;p&gt;参数列表中加入 &lt;code&gt;solver=&amp;quot;liblinear&amp;quot;&lt;/code&gt; 可以让上面两种方法达成同样的结果，但是这种求解器没有热启动，所以fit过程非常慢。&lt;/p&gt;</description></item><item><title>无需tex, 将ipynb转换为pdf</title><link>https://ziyuanding.github.io/posts/%E6%97%A0%E9%9C%80tex%E5%B0%86ipynb%E8%BD%AC%E6%8D%A2%E4%B8%BApdf/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate><guid>https://ziyuanding.github.io/posts/%E6%97%A0%E9%9C%80tex%E5%B0%86ipynb%E8%BD%AC%E6%8D%A2%E4%B8%BApdf/</guid><description>&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-powershell" data-lang="powershell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 这是一个 PowerShell 脚本，用于将 ipynb 笔记本转换为 PDF，无需安装 TeX。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 您需要先安装 nbconvert、pandoc 和 typst，才能运行此脚本。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 我不想安装 TeX，它太大了，至少有1G。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;pushd &lt;/span&gt;&lt;span class="nv"&gt;$PSScriptRoot&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nv"&gt;$filename&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;YOUR_IPYNB_FILE_NAME_WITHOUT_EXTENSION&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 将 .ipynb 文件转换为 .md&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 我删除了所有代码输入（--no-input）并通过添加标签 &amp;#34;remove_output&amp;#34; 删除了一些单元格的输出。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 你可能需要根据你的需求来修改这个地方，我这样改是因为我想在一个ipynb文件中写完所有的东西，然后从中生成各种格式的交付文件（报告、海报、ppt、甚至视频。。）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;jupyter&lt;/span&gt; &lt;span class="n"&gt;nbconvert&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="n"&gt;-output-dir&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;#34;out&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="n"&gt;-to&lt;/span&gt; &lt;span class="n"&gt;markdown&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;&lt;/span&gt;&lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="s2"&gt;.ipynb&amp;#34;&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="n"&gt;-no-input&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="n"&gt;-TagRemovePreprocessor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;enabled&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;True&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="n"&gt;-TagRemovePreprocessor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="py"&gt;remove_all_outputs_tags&lt;/span&gt; &lt;span class="n"&gt;remove_output&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 将 .md 文件转换为 .typ&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;pandoc&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="n"&gt;-from&lt;/span&gt; &lt;span class="n"&gt;markdown&lt;/span&gt; &lt;span class="p"&gt;-&lt;/span&gt;&lt;span class="n"&gt;-to&lt;/span&gt; &lt;span class="n"&gt;typst&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;out\&lt;/span&gt;&lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="s2"&gt;.md&amp;#34;&lt;/span&gt; &lt;span class="n"&gt;-o&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;out\&lt;/span&gt;&lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="s2"&gt;.typ&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 编译 .typ 文件，最终会得到 pdf 文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 点这里查看 typst 是什么 https://github.com/typst/typst&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;typst&lt;/span&gt; &lt;span class="n"&gt;compile&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;out\&lt;/span&gt;&lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="s2"&gt;.typ&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nb"&gt;popd
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description></item><item><title>在Typst里渲染R代码块运行结果</title><link>https://ziyuanding.github.io/posts/%E5%9C%A8typst%E9%87%8C%E6%B8%B2%E6%9F%93r%E4%BB%A3%E7%A0%81%E5%9D%97%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</link><pubDate>Wed, 29 Nov 2023 00:00:00 +0000</pubDate><guid>https://ziyuanding.github.io/posts/%E5%9C%A8typst%E9%87%8C%E6%B8%B2%E6%9F%93r%E4%BB%A3%E7%A0%81%E5%9D%97%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C/</guid><description>&lt;h2 id="typst是什么"&gt;Typst是什么&lt;/h2&gt;
&lt;p&gt;Typst是一个文档排版工具，包含一种标记语言，一个编译工具，还有正在快速发展的生态。Typst语言有一套有趣的语法，相对Tex语言来说可以更加简洁明了地表达大部分文档排版的需求。&lt;/p&gt;
&lt;h2 id="为什么要在typst里渲染r代码块的运行结果"&gt;为什么要在Typst里渲染R代码块的运行结果？&lt;/h2&gt;
&lt;p&gt;主要是期望在Typst中也能做到文学编程。而R语言又常常是文学编程中“编程&amp;quot;的那一部分。&lt;/p&gt;
&lt;h2 id="现阶段的问题"&gt;现阶段的问题&lt;/h2&gt;
&lt;p&gt;通过使用knitr, 现在其实已经可以比较好地渲染文本类输出了。主要是图片信息显示格式错误。而这个错误又是因为knitr官方在当前时间点（2023年11月）并不支持typ文件的织入，只不过typ文件的代码块语法和md文件类似，而knitr在fallback情况下又是使用md语法去抓取代码块和织入结果，所以造成了”只有文本输出正常，图片输出有bug“的错觉——人家本就完全不支持。&lt;br&gt;
相关issue: &lt;br&gt;
&lt;a href="https://github.com/typst/typst/issues/1978"&gt;https://github.com/typst/typst/issues/1978&lt;/a&gt; &lt;br&gt;
&lt;a href="https://github.com/yihui/knitr/issues/2283"&gt;https://github.com/yihui/knitr/issues/2283&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="如何做"&gt;如何做？&lt;/h2&gt;
&lt;p&gt;然而，knitr是一个相当自由的工具，在其工作流的前前后后，都有丰富的hook可供使用。对于我们的问题来说，我们只需要把图片输出修好，就可以完成临门一脚，使其凑凑活活达成我们的目标。
这里，我编写了一个plot函数的hook，只要把这段代码放在typ文档的最前面（当然，这段代码本身只需要被执行而不需要被渲染），就可以使后续文章中所有R代码输出的图片都会被knitr正确地以typst的格式织入。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-R" data-lang="R"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;# this chunk should be at the beginning of your paper. chunk option should be {r, echo=FALSE}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;local&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;hook_old&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;knitr&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;knit_hooks&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;plot&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;knitr&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;knit_hooks&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="nf"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt; &lt;span class="c1"&gt;## function(x, options) {&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;#print(options)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;image_path&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;paste&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="n"&gt;fig.path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="n"&gt;fig.cur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;.&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="n"&gt;fig.ext&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sep&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;image_caption&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="n"&gt;fig.cap&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;result_string&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nf"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#34;#figure(\n image(\&amp;#34;%s\&amp;#34;, width:%s),\n caption: [%s],\n)&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;image_path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="n"&gt;out.width&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;image_caption&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我这里只是用来验证想法，写的很简陋，图像控制的参数我只传了caption 和 width。但是可能性是无限大的，你想要什么自己手动添加参数就好了。&lt;/p&gt;
&lt;p&gt;实际的工作流稍显麻烦，但至少能用了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写typ文件（我们就叫这个文件feed-me-to-knitr.typ吧），记得把上述代码加到开头&lt;/li&gt;
&lt;li&gt;R会话里运行命令 &lt;code&gt;knit(&amp;quot;feed-me-to-knitr.typ&amp;quot;, &amp;quot;feed-me-to-typst.typ&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;命令行运行&lt;code&gt;typst compile &amp;quot;feed-me-to-typst.typ&amp;quot; final.pdf&lt;/code&gt;，得到最终的pdf文件
上述提到的这些示例文件可以在这里下载到：
#link(&amp;ldquo;&lt;a href="https://github.com/yihui/knitr/files/13463399/typst-r.zip%22"&gt;https://github.com/yihui/knitr/files/13463399/typst-r.zip&amp;quot;&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>在2023年用Typst写博客</title><link>https://ziyuanding.github.io/posts/%E5%9C%A82023%E5%B9%B4%E7%94%A8typst%E5%86%99%E5%8D%9A%E5%AE%A2/</link><pubDate>Fri, 24 Nov 2023 00:00:00 +0000</pubDate><guid>https://ziyuanding.github.io/posts/%E5%9C%A82023%E5%B9%B4%E7%94%A8typst%E5%86%99%E5%8D%9A%E5%AE%A2/</guid><description>&lt;h2 id="typst是什么"&gt;Typst是什么&lt;/h2&gt;
&lt;p&gt;Typst是一个文档排版工具，包含一种标记语言，一个编译工具，还有正在快速发展的生态。Typst语言有一套有趣的语法，相对Tex语言来说可以更加简洁明了地表达大部分文档排版的需求。&lt;/p&gt;
&lt;h2 id="用typst写博客有哪些困难"&gt;用Typst写博客有哪些困难&lt;/h2&gt;
&lt;p&gt;Typst官方将取代Tex做为主要目标，所以将Typst文件渲染为pdf之外的格式对他们来说并不是非常重要。在2023年11月这个时间点上，Typst官方支持的输出格式仅有pdf。导出为HTML文件的功能正在开发，但具体几时完成仍未可知。&lt;/p&gt;
&lt;p&gt;尽管如此，我们仍然可以尝试使用Typst做一些写论文以外的事情，比如用Typst写博客。感谢pandoc和Typst.ts，上述提到的输出格式的问题可以被绕过去了。总的来说，用Typst写博客现在并不会太麻烦，本文接下来就将展示使用Typst写博客的三种办法。&lt;/p&gt;
&lt;h2 id="使用pandoc将typ文件转换为html"&gt;使用Pandoc将typ文件转换为html&lt;/h2&gt;
&lt;p&gt;核心命令如下，可以将typ文件转换为html文件。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-shell" data-lang="shell"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;pandoc -o &lt;span class="s2"&gt;&amp;#34;dist/&lt;/span&gt;&lt;span class="nv"&gt;$test&lt;/span&gt;&lt;span class="s2"&gt;.html&amp;#34;&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;test.typ&amp;#34;&lt;/span&gt; -s --mathml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这之后就容易了，只是要想办法把渲染好的html链接到你的主页里（index.html）。我这里写了一个最简单的github pages，#link(&amp;ldquo;&lt;a href="https://github.com/ziyuanding/ziyuanding.github.io/releases/tag/demo_write_blog_in_typst%22)%5B"&gt;https://github.com/ziyuanding/ziyuanding.github.io/releases/tag/demo_write_blog_in_typst&amp;quot;)[&lt;/a&gt;
源码在这里
]。
没有用框架，主要的内容都在&lt;code&gt;.github\workflows\mybuild.yml&lt;/code&gt;里。&lt;/p&gt;
&lt;p&gt;如果你使用的是Hexo或Jekyll等流行的静态站点生成器，那可能就比较麻烦，我觉得你要么修改github action，想办法把typ转换得到的html塞到正常markdown渲染得到的html里；要么，就得去看一下这些站点生成器的插件系统，一般来说markdown到html这个流程也是通过markdown渲染插件实现的，我觉得应该也可以写一个typst渲染插件，然后这个插件里面调用pandoc之类的东西，这样会更有意思一点，推广起来很容易，大家接受度高。&lt;/p&gt;
&lt;h2 id="使用typstts将typ文件渲染为svg"&gt;使用Typst.ts将typ文件渲染为svg&lt;/h2&gt;
&lt;p&gt;#link(&amp;ldquo;&lt;a href="https://github.com/Myriad-Dreamin/typst.ts%22)%5BTypst.ts%5D"&gt;https://github.com/Myriad-Dreamin/typst.ts&amp;quot;)[Typst.ts]&lt;/a&gt; 是可以在浏览器里运行的Typst实现，对我们来说，它的主要功能就是可以把typ文件渲染成svg。它提供了一个&lt;code&gt;all-in-one.bundle.js&lt;/code&gt;，可以很方便地嵌入到你自己的网页里。&lt;/p&gt;
&lt;p&gt;然后它是动态的，应该是每次打开一个博文页面的时候：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从url里拿到typ文件地址&lt;/li&gt;
&lt;li&gt;读取这个文件到js对象&lt;/li&gt;
&lt;li&gt;交给typst.ts即时渲染成svg，展示到页面上。
我能想到的主要问题是。。这个可能不是很适合SEO，毕竟每个svg里每个文字都是一个需要查表的对象。。不过人家开发这个项目可能也没想着让我们写博客。用来做preview或者写电子书是挺好的（事实上也确实是这么做的）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="等typst官方实现"&gt;等Typst官方实现&lt;/h2&gt;
&lt;p&gt;啊，这也算吗？算吧，怎么不算呢，这有个#link(&amp;ldquo;&lt;a href="https://github.com/typst/typst/issues/721%22)%5Bissue%5D"&gt;https://github.com/typst/typst/issues/721&amp;quot;)[issue]&lt;/a&gt;慢慢等吧。&lt;/p&gt;</description></item></channel></rss>